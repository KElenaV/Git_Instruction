### Навигация

* **pwd** - показывает рабочую папку
* **ls** - показывает файлы и папки в текущей папке
* **cd** - команда перехода в другую дирректорию. Если папка находится в рабочем пространстве, то просто указывается ее имя, если в другом месте, то нужно указать подробный адрес
* **cd ..** - переход на уровень выше
* **cd /** - переход в корневую директорию
* **cd ~** - переход в домашнюю директорию

### Работа с файлами и папками

* **..** - обращение к родительской папке

### Создание
* **touch** - создает файл (желательно указывать расширение файла при создании) - если нужно создать несколько файлов указать их через пробел
* **mkdir** - создает папку

### Копирование - перемещение
* **cp fileName.txt directory** - копирует файл в указанную директорию
* **mv fileName.txt directory** - перемещает файл в указанную директорию

### Чтение
* **cat fileName.txt** - распечатывает содержимое текстового файла в консоль

### Удаление
* **rm** - удаление файла
* **rmdir** - удаление папки
* **rm -r** - удаление папки со всем ее содержимым

### Полезные возможности
* Можно в 1 строчке задать несколько команд через &&
* С помощью стрелок вверх-вниз можно перемещаться по буферу, хранящему все предыдущие команды
* Tab - 1 или 2 щелчок выводит подсказки

###Работа с Git
* **git config --global user.name "Name"** - задать имя пользователя
* **git config --global user.email email** - указать электронную почту

### Репозиторий
* **git init** - сделать папку-проект репозиторием. Нужно быть внутри папки. После этого появится слово main или master
* **rm -rf .git** - удалить папку git. В этой папке хранится вся история изменений. Если ее удалить вся история проекта будет стерта. Останется лишь последняя версия файлов.
* **git status** - текущее состояние репозитория
* **git add --all** - подготовит все файлы для сохранения в репозиторий
* **git add fileName.txt** - подготовит конкретный файл для сохранения в репозиторий
* **git commit -m "Comment"** - сохраняет текущую версию файлов в репозиторий с комментарием
* **git log** - выводит на консоль все коммиты в обратной хронологии (чтобы выйти из режима журнала - нажать q)
* **git log --oneline** - сокращенный список коммитов - отображаются только первые несколько символов хэша каждого коммита и комментарии - это удобно, когда уже сотни коммитов и нужно быстро найти нужный. Надпись (HEAD -> master) указывает на самый новый (последний) коммит.

### SSH ключи для шифрования данных (приватный и публичный-pub)
* **ls -la .ssh/** - выводит список созданных ключей - нужно находится в директории, где размещены ключи - по умолчанию это домашняя директория
* **ssh-keygen -t ed25519 -C "email"** - генерирует ключи, почта д.б. та к которой привязан аккаунт GitHub
* **ssn-keygen -t rsa -C "email"** - то же самое, но при другом алгоритме шифрования

После ввода данной команды появится сообщение: Enter a file... где нужно указать место хранения ключей. Если нажать ввод - ключи сохранятся в домашний каталог. Далее будет 2 сообщения, запрашивающих кодовую фразу и ее подтверждение - можно ввести код, а можно просто нажать ввод, тогда кода не будет.
* **ls -a ~/.ssh** - проверка сгенерированы ли ключи в домашней директории

### Привязка ключей к GitHub
* **clip < ~/.ssh/id_ed25519.pub** - скопировать содержимое файла (Windows)
* **clip < ~/.ssh/id_rsa.pub** - то же самое для другой системы шифрования
* **cat ~/.ssh/id_ed25519.pub** - если предыдущие команды не работают, можно с помощью данной команды распечатать файл на экран и скопировать его вручную.

Перейти в GitHub - Settings - SSH and GPG keys - New SSH key.
* **Title** - написать название ключа (напр. Personal key)
* **Key type** - Authentication
* **Key** - вставить скопированное ранее содержимое файла
* **Add SSH Key**

### Проверка правильности ключа и подтверждение подлинности сервера
* **ssh -T git@github.com** - проверка правильности ключа. Возможно, появится сообщение о том, что нужно подтвердить подлинность сервера. Это делается сверкой сгенерированного ключа SHA256 с возможными ключами, которые можно посмотреть на сайте docs.GitHub.com - Authentication - Account security - SSH key fingerprints - если ключи совпадают - нажать yes

### Привязка удаленного репозитория к локальному
1. Зайти в удаленный репозиторий - Нажать HTTP - Скопировать адресную строку справа
2. В консоли перейти в каталог локального репозитория
3. Ввести git remote add origin адресная строка из п.1 (вставку можно выполнить через контекстное меню - ПКМ, или Ctrl+Shift+V)

* **git remote -v** - если репозитории связались, то появится 2 строчки, заканчивающиеся на (fetch) (push)

### Отправить изменения на удаленный репозиторий
* **git push** - загружает содержимое локального репозитория на GitHub
* **git push -u origin main(or master)** - при первой отправке содержимого с локального на удаленный репозиторий

Многие команды Git принимают в качестве параметра хеш коммита. Если нужно передать последний коммит, то вместо его хэша можно просто написать слово HEAD - Git поймет, что вы имели в виду последний коммит.

## Статусы файлов в Git
1. **Untracked** - Git знает о существовании файла, но не следит за изменениями в нем. Это новый файл.
2. **Tracked** - все файлы после git commit и git add, т.е. те в которых отслеживаются изменения.
3. **Staged** - подготовленный - после выполнения команды git add (то же что и indexed или cached).
4. **Modified** - измененный - Git сравнил содержимое файла с последнего сохранения и нашел отличия.

 Большинство файлов в проекте будут в состоянии **tracked** (т.е. закомичены и не изменены после коммита). Это состояние не отражается через **git status**
* **git status** содержит инструкцию-подсказку того, что можно сделать для смены состояния файла 

### Оформление коммитов
* Сообщение д.б. коротким (не больше 72 символов - такую длину можно увидеть вызвав **git log --oneline**) и информативным для легкости чтения
* В начале коммита можно ставить уточнение типа изменений (feat - новая функциональность, fix - исправление, м.б. и другие) 
* В скобках () - не обязательно - существительное, указывающее часть кодовой базы, которую затронул коммит
* ! - если нужно привлечь внимание к коммиту
* Далее двоеточие и краткое описание после пробела
* Тело описания (если требуется более подробная информация) должно отделяться от короткого описания одной пустой строкой.
* Подвал м.б. представлен после тела через 1 пустую строчку и должен содержать мета-информацию о коммите, например связанные запросы, обсуждения, изменения нарушающие обратную совместимость. По 1 мета-информации на строчку.
* Изменения, нарушающие обратную совместимость д. быть либо в начале тела, либо в начале подвала и начинаться с заглавных BREAKING CHANGE
* Текст д.б. написан нерегистрозависимым способом - маленькими буквами
* Также в коммите можно напрямую указывать №задачи (#номер задачи), которую тот решил - т.о. GitHub свяжет коммит и задачу
* Рекомендуется использовать глаголы в повелительном наклонении (Use library, Исправить ошибку)

### Как исправить коммит
* **git commit --amend --no-edit**
 --amend не создает новый коммит, а дополняет последний. Например, добавляются файлы или вносятся изменения в содержимое файлов. Коммит останется тот же, но его хэш-тег изменится, т.к. поменялось содержимое коммита.
--no-edit оставляет сообщение коммита без изменения
* **git commit -m "Message"** 
 Если понадобилось изменить сообщение, при этом не обязательно менять содержимое файлов.
Если забыть указать у команды 1 из флагов (--no-edit / -m) - откроется текстовый редактор, чтобы отредактировать сообщение коммита вручную. Можно просто закрыть его.

## Как откатиться назад
### Откатить добавленный файл (restore - "восстановить")
* **git restore --staged file.txt** переводит файл из staged обратно в untracked/modified
* **git restore --staged .** если нужно сбросить всю текущую папку
### Откатить закомиченный файл (reset - "сброс, обнуление")
* **git reset --hard hash** - хэш номер коммита на который мы хотим вернуться можно найти с помощью *git log --oneline*
Очень осторожно использовать эту функцию т.к. файлы после нее также возвращаются к тому состоянию, в котором были в момент возвращенного коммита или даже удалится, если его не было на тот момент. Есть риск удалить что-то нужное, т.к. потеряются все более поздние от возвращаемого коммиты.
### Откатить изменения, которые не попали ни в staging, ни в коммит
* **git restore file.txt** - откатывает назад изменения файлов, которые находятся в статусе modified. Изменения в файле откатятся до последней версии, которая была сохранена через git commit или git add

## Просмотр изменений в файлах
* **git diff** - сравнивает последнюю закоммиченную версию файла с текущей (измененной) версией в статусе modifie
В выводе информации есть строчка похожего содержания @@ -15,7 +15,7 @@ , где цифра 15 означает с какой строки начинается сравнение, а вторая сколько строк сравнивалось. Здесь сравнивались 7 строк, начиная с 15. Это удобно для ориентирования в большом коде.
* **git diff** по умолчанию не показывает изменения в staged файлах, только в modified
* **git diff --staged** чтобы увидеть изменения в staged файлах
* **git diff hash1 hash2** - сравнивает содержимое 2 закомиченных файлов. В качестве hash указать коды коммитов, отображаемые при вызове 
*git log --oneline*. Последний коммит можно указывать не кодом, а словом HEAD. Порядок хэш-аргументов в запросе меняет хронологию изменений.
* **git diff** по умолчанию не показывает изменения в staged файлах, только в modified
* **git diff --staged** чтобы увидеть изменения в staged файлах
* **git diff hash1 hash2** - сравнивает содержимое 2 закомиченных файлов. В качестве hash указать коды коммитов, отображаемые при вызове *git log --oneline*. Последний коммит можно указывать не кодом, а словом HEAD. Порядок хэш-аргументов в запросе меняет хронологию изменений.
- -/красный цвет - то, что удалилось
- +/зеленый цвет - то, что добавилось
- черный цвет без знака - контекст, чтобы сориентироваться в расположении изменений в файле

## Добавление текста в файл через консоль
* **echo "Text" >> file.txt** - вставляет написанный в кавычках текст в указанный файл в конец
* **echo "Text" > file.txt** - вставляет текст в указанный файл предварительно стерев предварительно все содержимое файла - т.е. перезаписывает файл


